%-------------------------------------------------------------------------------
%                            BAB II
%               TINJAUAN PUSTAKA DAN DASAR TEORI
%-------------------------------------------------------------------------------
\fancyhf{} 
\fancyfoot[C]{\thepage}
\chapter{TINJAUAN KEPUSTAKAAN}

\par Untuk mendukung penelitian ini, maka dalam bab ini akan dikemukakan beberapa rumusan teori pendukung, yang dikutip dari berbagai referensi baik dalam bentuk buku, artikel, maupun tulisan karya ilmiah lainnya termasuk hasil penelitian sebelumnya yang ada kaitannya dengan penelitian yang dilakukan.

\section{\textit{Indoor Positioning System}}
\textit{Indoor Positioning System} (IPS, atau \textit{"Indoor Location System"}) merupakan teknologi yang menyediakan informasi bagi pengguna berdasarkan lokasi pengguna di dalam sebuah gedung \citep{brena2017evolution}. IPS merupakan proses mendapatkan perangkat atau lokasi pengguna di dalam ruangan atau lingkungan \citep{zafari2019survey}. Banyak penelitian yang dilakukan dalam mengimplementasi IPS dengan berbagai pemanfaatan seperti WLAN. Namun pemanfaatan WLAN memiliki konsumsi daya yang boros pada smartphone sehingga pada akhirnya implementasi IPS diterapkan pada \textit{Bluetooth low Energy} (BLE) yang memiliki konsumsi daya yang lebih rendah. Metode yang dapat dilakukan dalam pengimplementasian IPS adalah metode \textit{trilateration} (berdasarkan jarak), \textit{triangulation} (berdasarkan sudut) dan \textit{fingerprinting} \citep{puspitasari2020}.

\par Pada luar ruangan untuk mendeteksi suatu lokasi sudah diterapkan dengan adanya teknologi GPS, di mana GPS banyak memberikan dampak yang luar biasa pada kehidupan sehari-hari. Namun kegunaan GPS atau sistem lokasi berbasis satelit hanya terbatas pada lingkungan di luar ruangan. Dengan demikian dibutuhkan suatu metode dan teknologi khusus untuk sistem lokasi pada dalam ruangan yang disebut sebagai \textit{Indoor Positioning System} (IPS) \citep{brena2017evolution}. Dengan menggunakan sensor dan teknologi komunikasi sistem penentuan posisi pada IPS dapat menemukan objek di lingkungan dalam ruangan. Peluang pasar pada penggunaan IPS cukup besar sehingga dapat menarik minat ilmiah komunikasi untuk menerapkan teknologi tersebut \citep{brena2017evolution}.

\par Pada teknologi IPS memiliki beberapa pendekatan yaitu, menentukan posisi dengan berbasis WiFi (WPS), menentukan posisi berbasis \textit{Bluetooth Low Energy} (BLE), menentukan posisi berbasis Identifikasi Frekuensi Radio (RFID) dan menentukan posisi dengan menggunakan teknologi \textit{Ultra-Wide Band} (UWB) atau \textit{Visible Light Communication} (VLC) \citep{canton2017bluetooth}. IPS juga dapat dipadukan dengan kemampuan \textit{route guidance} atau pemandu rute serta didampingi dengan sistem pemandu dengan suara.


\section{\textit{Route Guidance System / Wayfinding and Navigation System}}
Menurut \citep{karimi2015indoor}, \textit{Wayfinding and navigation system} memiliki 2 makna, yaitu merupakan perangkat khusus yang menyediakan solusi pencarian jalan dan navigasi tanpa memerlukan tautan komunikasi atau koneksi ke sistem lain dan tanpa penyedia pihak ketiga. Makna ke dua adalah referensi layanan melalui \textit{smartphone} yang menyediakan solusi pencarian arah dan navigasi hanya melalui tautan komunikasi kabel-nirkabel ke sistem jarak jauh yang didukung oleh penyedia pihak ketiga. Dari perspektif komputasi, \textit{Wayfinding and navigation system} adalah platform terpusat, terdistribusi, dan didistribusikan melalui klien (pada \textit{smartphone}) dan server yang dikelola oleh penyedia layanan.

\section{\textit{Bluetooth Low Energy)} (BLE)}
Teknologi \textit{Bluetooth} dikembangkan oleh Ericsson pada tahun 1994 dengan kegunaan sebagai standar komunikasi nirkabel untuk bertukar data dalam jarak dekat \citep{kaluvza2017analysis}. Teknologi \textit{Bluetooth} memiliki fitur utama yaitu memiliki biaya yang rendah, konsumsi daya rendah, jangkauan kecil, memiliki ketahanan dan penggunaan secara global. Kecepatan transfer data yang diberikan oleh \textit{Bluetooth} sebesar 1 Mbit/s dan menggunakan pita frekuensi tanpa izin 2,4 hingga 2,485 GHz \citep{kaluvza2017analysis}.

\par Pertengahan tahun 2010 spesial otoritas kompeten yang bernama â€œBluetooth Special Interest Group" (SIG) mengumumkan spesifikasi \textit{Bluetooth} 4.0, dimana meliputi : \textit{Bluetooth} Klasik, \textit{Bluetooth} dengan kecepatan tinggi, dan protokol \textit{Bluetooth} hemat energi. Karakteristik dari \textit{Bluetooth Low Energy} (BLE) adalah memiliki ukuran yang kecil, menggunakan biaya rendah, konsumsi penggunaan daya yang rendah dengan kemungkinan penggunaan sampai beberapa tahun bekerja dengan menggunakan baterai AAA dan memiliki kompatibilitas dengan perangkat seluler, tablet, dan komputer \citep{kaluvza2017analysis}.

\begin{figure}[H]
\centering
{\includegraphics [scale= .1]{gambar/bab2/BLE_Device}}
\caption{Perangkat Bluetooth Low Energy}.
\label{img:BLE_device}
\end{figure}

\subsection{\textit{Beacon}}
BLE memancarkan sinyal dari alat transmiter yang beroperasi menggunakan baterai. Alat transmiter tersebut disebut dengan \textit{Beacon}. \textit{Beacon} merupakan alat pendeteksi lokasi dengan harga yang terjangkau, ukurannya yang kecil, memiliki daya tahan baterai yang cukup lama, dan tidak membutuhkan energi listrik tambahan \citep{puspitasari2020}. Setiap perangkat \textit{smartphone} dan tablet yang mendeteksi sinyal dari \textit{Beacon}, dapat menghitung jarak dan memperkirakan keberadaan lokasi setiap perangkat sekaligus. \textit{Beacon Bluetooth} mengubah pengalaman menggunakan \textit{smartphone} untuk bepergian, berbelanja, bekerja, dan bermain \citep{kaluvza2017analysis}.

\section{\textit{Fingerprinting}}
\textit{Fingerprinting} adalah teknik untuk menentukan lokasi dengan pemanfaatan \textit{Radio Signal Strength} (RSS) dari suatu \textit{Access Point }(AP). Menurut \citep{yudha2018indoor} , metode ini memperhitungkan atenuasi karena kekuatan sinyal sering berubah-ubah. Setiap titik reverensi dikumpulkan yang mengintegrasikan adanya penghalang antara transmiter dan \textit{receiver}.

\par Transmiter untuk teknologi IPS yang ditunjukan untuk WLAN disebut dengan AP, sedangkan transmiter untuk teknologi IPS yang ditunjukan untuk \textit{Bluetooth Low Energy} disebut dengan \textit{Beacon } \cite{puspitasari2020}. Metode fingerprinting berbasis IPS ini terdiri dari 2 tahap. Tahap pertama adalah tahap pembelajaran (offline), di mana lokasi fingerprints itu sendiri diperoleh dengan cara mengumpulkan RSSI dalam satuan desibel (dB) yang dipancarkan dari masing-masing AP. Kemudian gelombang radio yang dipancarkan AP yang diletakkan pada posisi yang telah ditentukan sebelumnya ditangkap oleh smartphone yang terintegrasi dengan WLAN ataupun \textit{Bluetooth}.

\par Selama tahap pembelajaran lokasi yang tidak diketahui data pembelajarannya kemudian dirujuk sebagai titik referensi estimasi lokasi. Tahap kedua adalah tahap pengujian (\textit{online}), di mana keakuratan yang dikumpulkan dalam data pembelajaran. Selama tahap pengujian sistem harus memberikan lokasi setiap objek berdasarkan data RSSI yang diamati. Namun, nilai RSSI bisa dipengaruh oleh keadaan lingkungan sekitar yang dapat mengganggu keakuratannya \citep{subhan2011indoor}. Menurut \citep{yudha2018indoor}, metode Fingerprinting berbasis IPS ini melibatkan 2 tahap yang dapat dilihat pada Gambar \ref{img:fingerprinting}.

\begin{figure}[H]
\centering
{\includegraphics [scale=.5]{gambar/bab2/Fingerprinting}}
\caption{Ilustrasi Metode \textit{Fingerprinting} \citep{yudha2018indoor}}.
\label{img:fingerprinting}
\end{figure}

\subsection{\textit{Received Signal Strength Indicator} (RSSI)}
\textit{Received Signal Strength Indicator} atau RSSI adalah metode pengukuran jarak yang memperoleh sinyal dari transmiter seperti \textit{Bluetooth} untuk menentukan \textit{distance-loss} model, dan kemudian memperkirakan posisi pengguna melalui beberapa algoritma (\citep{li2018indoor}). Menurut \citep{puspitasari2020} \textit{Positioning System} menghasilkan data yang penting untuk menghitung lokasi pengguna. \textit{Time of Arrival} (TOA), \textit{Time Difference of Arrival} (TDOA), \textit{Angle of Arrival} (AOA). RSSI memperkirakan jarak \textit{node} yang belum diketahui ke referensi \textit{node} dari beberapa kumpulan unit perhitungan dengan menggunakan atenuasi kekuatan sinyal (\textit{signal strength}) yang dipancarkan oleh transmiter \citep{puspitasari2020}.

\par Nilai RSSI didefinisikan dengan bilangan negatif. Semakin tinggi bilangan negatifnya, maka kekuatan sinyal tersebut tergolong lemah. Namun apabila nilainya mendekati 0, maka sinyal tersebut tergolong kuat. RSSI dapat digolongkan menjadi 5 kategori kekuatan sinyal seperti Tabel \ref{tab:sinyal_rssi}

\begin{table}[H]
\caption{Kekuatan sinyal RSSI \citep{sideeq2016smart}}
\label{tab:sinyal_rssi}
\centering
\begin{tabular}{|l|l|l|}
\hline
{\color[HTML]{000000} \textbf{No.}} & \textit{\textbf{Signal Noise Ratio }}(SNR) & \textbf{RSSI} \\ \hline
1. & Kurang dari -40 dB   & Luar Biasa  \\ \hline
2. & -40 dB hingga -55 dB & Sangat Baik \\ \hline
3. & -55 dB hingga -70 dB & Baik        \\ \hline
4. & -70 dB hingga -80 dB & Cukup Baik  \\ \hline
5. & Lebih dari -80 dB    & Buruk       \\ \hline
\end{tabular}
\end{table}


\subsection{Kalman Filter}
Kalman Filter adalah seperangkat persamaan matematika yang menyediakan cara komputasi yang efisien untuk memperkirakan keadaan suatu proses, dengan cara meminimalkan rata-rata kesalahan kuadrat. Filter ini sangat berguna dalam beberapa aspek: mendukung estimasi-estimasi keadaan lampau, sekarang dan masa depan, dan dapat melakukannya bahkan ketika sifat pasti dari sistem yang dimodelkan tidak diketahui \cite{welch2020kalman}. Kalman Filter sendiri merupakan algoritma yang menggunakan serangkaian data yang diamati dari waktu ke waktu, yang mengandung \textit{noise} dan ketidakakuratan lainnya, untuk memperkirakan variabel yang tidak diketahui dengan lebih akurat. Ini diusulkan oleh R. E. Kalman pada tahun 1960, dan menjadi pendekatan standar untuk estimasi yang optimal. Karena memiliki keunggulan waktu secara \textit{realtime}, cepat, efisien, dan anti-interferensi yang kuat, Kalman filter telah banyak diterapkan di bidang perhitungan orbit, pelacakan target dan navigasi \cite{li2015kalman}.

\par Menurut \citep{ihsan2018analisis} berikut proses Kalman Filter dapat dilihat pada gambar dibawah ini:
\begin{figure}[H]
\centering
{\includegraphics [width = 10cm, height= 4cm]{gambar/bab2/kalman_filter}}
\caption{Ilustrasi Kalman Filter \citep{ihsan2018analisis}}.
\label{img:kalman_filter}
\end{figure}

Pada Kalman Filter dilakukan dengan dua tahapan yaitu tahap prediksi (\textit{time update}) dan tahap pembaruan (\textit{measurement update}) terhadap data-data pengukuran untuk memperbaiki hasil estimasi. Tahap prediksi adalah suatu tahapan untuk mengubah suatu keadaan menjadi keadaan berikutnya dengan mengabaikan error yang ada \citep{ihsan2018analisis}.

Berikut rumus menurut \citep{ihsan2018analisis}:
\begin{itemize}
\item \textit{Time Update (Predict)}

\par \textit{Predict State}
\begin{equation}
x = x
\end{equation}

\par \textit{Predict error covariance}
\begin{equation}
p = p + q
\end{equation}

\item \textit{Measurements update (Correct)}
\par \textit{Update the estimate via} k 
\begin{equation}
x = x + k*(measurement â€“ x)
\end{equation}

\par Kalman \textit{gain} 
\begin{equation}
k = p / ( p+r )
\end{equation}

\par \textit{Update the error covariance}
\begin{equation}
p = (1 â€“ k )* p
\end{equation}

\end{itemize}
\par Keterangan
\par x: Nilai yang di filter
\par p: Error estimasi
\par q: Noise yang diakibatkan dari proses
\par k: Kalman Gain
\par r: Noise dari sensor\newline


\par Kalman Filter menerima inputan \textit{gain} untuk meminimumkan kovariansi \textit{error}. Kalman gain berupa inputan \textit{high-gain} dan \textit{low-gain}, dimana \textit{high-gain} dapat mendekati posisi sebenarnya karena menghasilkan lintasan perkiraan lebih responsif sementara \textit{low-gain} dapat menghaluskan \textit{noise} namun mengurangi responsifnya. Oleh karena itu, semakin tinggi inputan nilai gain dari Kalman Filter maka semakin mendekati 
posisi sebenarnya \citep{ihsan2018analisis}.


\newpage
\section{\textit{Speech Recognition}}
\textit{Speech Recognition} adalah kemampuan suatu komputer agar dapat mengenali apa yang diucapkan oleh seseorang berdasarkan sinyal suara yang diucapkan oleh seseorang atau bisa disebut sebagai \textit{Automatic Speech Recognition} (ASR)\citep{jurafskyspeech2008}. \textit{Speech Recognition} merupakan antarmuka alami untuk berkomunikasi dengan peralatan komputer seperti \textit{smart home appliances}, \textit{personal assistants}, atau \textit{smartphone}. ASR Juga berguna untuk \textit{general transcription}, contohnya untuk membuat \textit{captions} secara otomatis untuk audio atau video (mentranskripsikan film atau video atau \textit{live discussions}) \citep{jurafskyspeech2008}. Menjadi suatu kemudahan bagi manusia jika komputer dapat memahami apa yang diucapkan oleh manusia dan karena hal itu juga manusia dapat dengan mudah mengoperasikan komputer karena adanya teknologi yang \textit{Automatic Speech Recognition}. serta \textit{speech synthesis} atau \textit{text-to-speech} (TTS) \citep{jurafskyspeech2008}.

\subsection{\textit{Text-to-Speech }(TTS)}
Speech Syntesis atau text-to-speech merupakan kebalikan dari ASR dalam memetakan teks ke bentuk gelombang akustik. TTS memilik berbagai macam aplikasi. TTS digunakan dalam agen percakapan yang berdialog dengan orang-orang, berperan dalam perangkat yang membacakan dengan keras untuk tunanetra atau dalam permainan, dan dapat digunakan untuk berbicara bagi penderita gangguan neurologis, seperti mendiang Steven Hawking seorang ahli astrofisika berbicara dengan memanipulasi sistem TTS \citep{jurafskyspeech2008}.



\section{VOSK API}
Vosk api merupakan toolkit untuk speech recognition, di mana memiliki beberapa kelebihan, yaitu \citep{cephei2019}:
\begin{enumerate}
\item Memiliki 19 lebih bahasa dan dialek yang didukung vosk.
\item Vosk api merupakan toolkit speech recognition yang bisa digunakan secara offline, yang dapat digunakan pada Raspberry Pi, Android, iOS.
\item Kemudahan untuk menginstalasi vosk dengan menggunakan pip3 install vosk.
\item Model yang portabel pada masing-masing bahasa sebesar 50Mb, namun ada beberapa model server yang lebih besar pula.
\item Menyediakan streaming API untuk pengalaman pengguna terbaik.
\item Memiliki beberapa paket bahasa pemograman yang berbeda-beda, seperti java, csharp, javascript dll.
\item Untuk akurasi terbaik dapat memungkinkan konfigurasi ulang kosakata dengan cepat.
\item Mendukung identifikasi pembicara selain dengan speech recognition yang sederhana.

\end{enumerate}

\section{Android}
Android merupakan suatu \textit{software} (perangkat lunak) yang digunakan pada \textit{mobile device}(perangkat berjalan)yang meliputi sistem operasi, \textit{middleware},dan aplikasi inti. Android \textit{Standart Development Kit} (SDK) menyediakan alat dan \textit{Application Programming Interface}(API) yang diperlukan untuk memulai pengembangan aplikasi pada platform Android menggunakan bahasa pemrograman Java, yaitu kode Java yang terkompilasi dengan data dan \textit{file resources} yang dibutuhkan aplikasi dan digabungkan oleh \textit{app tools} menjadi paket Android. \textit{File} tersebut ditandai dengan ekstensi .apk. \textit{File} inilah yang didistribusikan sebagai aplikasi dan dipasang pada perangkat \textit{mobile} \citep{nasution2018perancangan}.

\par Menurut \citep{shaheen2017android}. Ada 4 jenis komponen aplikasi. Setiap jenis memiliki tujuan yang berbeda dan memiliki siklus proses yang berbeda yang menentukan bagaimana komponen di \textit{create} dan di \textit{destroy}. Berikut adalah ke 4 jenis komponen tersebut:

\begin{enumerate}
\item \textit{Activities}, merupakan sebuah \textit{activity} merepresentasikan tampilan aplikasi kepada pengguna (\textit{user interface}).
\item \textit{Service}, merupakan komponen yang berjalan pada \textit{background} untuk menjalankan operasi atau proses yang tidak memiliki \textit{user interface}.
\item \textit{Content Providers}, merupakan komponen yang menangani data antar aplikasi.
\item \textit{Broadcast Receivers}, merupakan komponen yang bertanggung jawab atas menerima serta menyampaikan informasi atau notifikasi.
\end{enumerate}

\section{Android Studio}
Android Studio merupakan \textit{Integrated Development Environtment} (IDE) untuk pengembangan platform Android. Android Studio diumumkan pada tanggal 16 Mei 2013 di Google I/O \textit{Conference}. Android Studio dapat digunakan secara gratis di bawah pengawasan Apache \textit{License} 2.0. Android Studio merupakan kolaborasi antara JetBrains dan Google. Android Studio mirip dengan Eclipse yang disertai dengan ADT \textit{Plugin} (Android \textit{Development Tools})\citep{craig2015learn}.

\par Fitur-fitur Android Studio menurut \citep{puspitasari2020} adalah sebagian berikut:
\begin{itemize}
\item Proyek berbasis pada Gradle \textit{Build}.
\item \textit{Refactory} dan perbaikan bug yang cepat.
\item \textit{Tools} baru yang bernama "Lint" diklaim dapat memonitor kecepatan, kegunaan, serta kompatibilitas aplikasi dengan cepat.
\item Mendukung Proguard and \textit{App-signing} untuk keamanan.
\item Memiliki GUI aplikasi Android lebih mudah.
\item Didukung oleh Google \textit{Cloud Platform}, sehingga lebih mudah mengintegrasi Google \textit{Cloud Messaging and Application Engine} untuk setiap aplikasi yang dikembangkan.
\end{itemize}

\section{SCRUM}
\textit{Scrum} adalah \textit{development framework} di mana tim lintas-fungsi mengembangkan produk atau proyek secara berulang dan bertahap. \textit{Scrum} menyusun siklus pengembangan yang disebut \textit{Sprint}. Iterasi ini masing-masing tidak lebih dari empat minggu dan berlangsung satu demi satu tanpa jeda \citep{deemer2012lightweight}. \textit{Sprint} memiliki durasi tetap atau \textit{Sprint} berakhir pada tanggal tertentu baik selesai atau belum, dan tidak pernah diperpanjang. Oleh karena itu \textit{Sprint} dikatakan \textit{timeboxed} \citep{schwaber2011scrum}. Tahapan-tahapan metode \textit{Scrum} menurut \citep{schwaber2011scrum} adalah sebagai berikut :

\begin{enumerate}
\item Dimulai dengan mengumpulkan \textit{user requirements}, namun tidak harus semua \textit{requirements} diharapkan harus keluar dari pemikiran pengguna di tahap awal proses pengembangan. Pengguna dapat mengubah pikiran mereka di setiap waktu selama proses pengembangan, pengguna dapat menambah fitur-fitur baru, menghapus atau memperbaharui beberapa fitur yang telah ada sebelumnya.

\item Tahapan selanjutnya adalah memprioritaskan \textit{requirements} dan \textit{Product Backlog}. Sebuah perencanaan yang tepat dalam \textit{Sprint} harus dilakukan sesuai dengan jumlah Sprint yang dibutuhkan untuk mengembangkan perangkat lunak, yang terdiri dari durasi \textit{Sprint} tersebut dan \textit{requirements} apa saja yang terdapat di \textit{Product Backlog} yang harus diimplementasikan di setiap \textit{Sprint} (dikenal dengan \textit{Sprint Backlog}).

\item \textit{Sprint} diawali dengan \textit{Sprint Planning} di mana \textit{Product Owner}, satu orang uang telah diberikan wewenang dan bertanggung jawab untuk memaksimalkan nilai produk di pasar, bertemu dengan tim \textit{Scrum} (tim dengan jumlah 2-9 orang), kemudian bekerja sama untuk memperkirakan \textit{requirements} dari \textit{Product Backlog} apa saja yang dikerjakan selama satu \textit{Sprint}.

\item \textit{Sprint Planning} difasilitasi dengan \textit{Scrum Master}. \textit{Scrum Master} adalah seorang pemimpin yang melayani (\textit{Servant Leader}). \textit{Sprint Planning} memiliki batasan waktu selama 8 jam di dalam sebuah \textit{Sprint} yang berdurasi selama 30 hari. Keluaran dari \textit{Sprint Planning} adalah daftar pekerjaan dari hasil kesepakatan antara \textit{Product Owner} dan tim \textit{Scrum} di mana pekerjaan itu yang dikerjakan oleh tim \textit{Scrum} nantinya selama satu \textit{Sprint} beserta \textit{Sprint Goal} yang dinamakan dengan \textit{Sprint Backlog}.

\item Setelah \textit{Sprint Planning} berakhir, tim \textit{Scrum} akan mengambil \textit{Sprint Backlog} untuk diri mereka masing-masing dan mengerjakan \textit{Sprint Backlog} setiap hari hingga akhir \textit{Sprint} tanpa campur tangan dari pihak mana pun. \textit{Daily Scrum} akan dikerjakan oleh tim \textit{Scrum} yang tidak lebih dari 15 menit untuk menentukan apa saja yang akan mereka kerjakan selama 24 jam ke depan berdasarkan perkembangan 24 jam terakhir, serta menyampaikan permasalahan yang menghambat mereka untuk bisa mencapai \textit{Sprint Goal}. Tim \textit{Scrum} akan melakukan perbaikan-perbaikan item dari \textit{Product Backlog} pada \textit{Sprint} yang akan datang selama proses pengembangan berlangsung, dengan tujuan membuat \textit{Sprint Planning} menjadi lebih efektif.

\item Di akhir Sprint saat acara \textit{Sprint Review}, \textit{Product Owner} akan mempresentasikan hasil pekerjaan tim \textit{Scrum} selama satu \textit{Sprint} dan juga menjelaskan apa saja pencapaian tim \textit{Scrum} menuju \textit{Sprint Goal} di dalam \textit{Sprint} tersebut kepada para pemegang kepentingan (\textit{stakeholder}) agar mendapatkan \textit{feedback}. \textit{Feedback} ini akan dimasukkan ke dalam \textit{Product Backlog} agar meningkatkan nilai dari sebuah produk. \textit{Sprint Review} memiliki batasan waktu tidak lebih dari 4 jam untuk \textit{sprint} yang memiliki durasi selama 30 hari.

\item Setelah \textit{Sprint Review}, \textit{Scrum Master} memfasilitasi acara yang bernama \textit{Sprint Retrospectives} agar tim \textit{Scrum}, \textit{Product Owner} bekerja sama menentukan apa saja peningkatan yang akan mereka implementasikan di \textit{Sprint} berikutnya. \textit{Definition of Done} adalah salah satu hal yang ditekankan oleh tim \textit{Scrum} pada saat \textit{Sprint Retrospectives}.


\newpage
\item \textit{Sprint Retrospectives} merupakan acara yang paling penting dalam \textit{Scrum} dikarenakan sifatnya yang menekankan \textit{continuous learning} yang dapat meningkatkan tingkat \textit{agility} perusahaan. \textit{Sprint Review} memiliki batasan waktu tidak lebih dari 3 jam untuk \textit{Sprint} yang memiliki durasi selama 30 hari. Setelah \textit{Sprint Retrospectives} berakhir, maka \textit{Sprint} berikutnya akan langsung dilakukan tanpa jeda antar \textit{Sprint}. Pada setiap \textit{Sprint}, \textit{Product Owner} akan memastikan agar produk mencapai nilai setinggi mungkin saat pengembangan produk diakhiri. \textit{Product Owner}, \textit{Scrum Master} dan tim \textit{Scrum} memegang komitmen, keberanian, saling menghargai satu sama lain, keterbukaan dan fokus. Ilustrasi tahapan-tahapan metode \textit{Scrum} dapat dilihat pada \ref{img:scrum} di bawah ini.
\end{enumerate}

\begin{figure}[H]
\centering
{\includegraphics [width = 14cm, height= 5cm]{gambar/bab2/Scrum}}
\caption{Ilustrasi Metode Pengembangan Menggunakan Scrum \citep{schwaber2011scrum}.}.
\label{img:scrum}
\end{figure}

\section{\textit{Black Box Testing}}
Salah satu jenis pengujian fungsional adalah \textit{blackbox testing}. \textit{Blackbox} testing merupakan suatu pengujian yang tidak menggunakan pengetahuan tentang struktur interior aplikasi. Saat melakukan pengujian, penguji akan berinteraksi langsung dengan \textit{user interface}, lalu penguji akan memberikan masukan dan memeriksa hasil dari aplikasi yang digunakan tanpa mengetahui bagaimana proses dari hasil tersebut \citep{xu2016comparative}. Pada \textit{blackbox testing} mendapatkan pengujian dari deskripsi eksternal perangkat lunak, termasuk spesifikasi, persyaratan, dan desain \citep{ammann2016introduction}.

\par \textit{Blackbox testing} memiliki beberapa keuntungan, di antaranya penguji tidak perlu mengetahui suatu bahasa pemrograman, pengujian dilakukan dari sudut pandang pengguna agar dapat mengetahui suatu inkonsisten pada spesifikasi kebutuhan serta yang terakhir programmer dan penguji dapat saling bergantung \citep{jaya2018pengujian}. \textit{Blackbox testing} juga memiliki beberapa kekurangan yaitu suatu pengujian sulit didesain tanpa spesifikasi yang jelas, memiliki kemungkinan untuk pengulangan \textit{testing} dan tidak ada pengujian pada bagian \textit{back-end} \citep{jaya2018pengujian}.

\section{\textit{Usability Testing}}
\textit{Usability Testing} adalah kegiatan pengujian untuk mengumpulkan data mengenai sebuah produk dalam tahap pengembangan. Tujuan utama dari \textit{usability testing} adalah untuk mengumpulkan data kuantitatif dengan mengukur waktu untuk mengidentifikasi dan memperbaiki kekurangan yang ada dalam produk serta bahan pendukung yang menyertainya sebelum produk dirilis \citep{rubin2008handbook}. Dengan \textit{usability testing}, didapati apa yang sebenarnya dilakukan pengguna, apa yang berhasil untuk mereka, dan apa yang tidak dipikirkan akan mereka lakukan atau bahkan apa yang mereka pikir akan mereka lakukan jika menggunakan produk \citep{barnum2020usability}.


\par Pengujian ini diharapkan akan mendapatkan kekuatan dan kelemahan dari setiap aspek yang ada pada aplikasi itu sendiri. Maka dari itu, perlu adanya dokumentasi pengalaman aktual para calon pengguna aplikasi atau produk saat dievaluasi \citep{wesfix2017branding}. Tujuan lain dilakukannya pengujian ini adalah untuk mengumpilkan data kualitatif yang berhubungan dengan produk yang diuji. Data kualitatif tersebut terdiri dari komentar yang dibuat oleh partisipan, jawaban dari kuesioner pertanyaan dan tanggapan dari partisipan saat proses wawancara. \textit{Usability testing} telah terbukti dapat mengurangi waktu pada tahap pengembangan, mengurangi jumlah bugs, dan menghasilkan produk yang lebih berkualitas untuk meningkatkan nilai jual \citep{wahl2000student}.

\subsection{\textit{Usability Metric for User Experience} (UMUX)}
UMUX merupakan salah satu instrumen kuesioner standar selain \textit{System Usability Scale} (SUS). Meskipun SUS merupakan kuesioner yang relatif singkat, ada beberapa situasi di mana instrumen yang lebih pendek lebih disukai (misalnya, ketika ada kebutuhan untuk mengukur lebih banyak atribut daripada hanya kegunaan yang dirasakan yang mengarah ke sesuatu yang tetap serta terbatas untuk atribut apa pun). UMUX dirancang di Intel untuk mendapatkan pengukuran yang dirasakan konsisten dengan SUS, tetapi hanya menggunakan empat (bukan 10) item (Lewis, 2018).

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[H]
\caption{Daftar Pertanyaan Metode UMUX.}
\label{tab:UMUX}
\resizebox{\columnwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
1 & Kemampuan sistem ini memenuhi persyaratan saya.                  \\ \hline
2 & Menggunakan sistem ini adalah
pengalaman yang membuat frustrasi.  \\ \hline
3 & Sistem ini mudah digunakan.                                       \\ \hline
4 & Saya harus menghabiskan terlalu banyak waktu untuk
memperbaiki hal-hal dengan sistem ini. \\ \hline
\end{tabular}%
}
\end{table}

\par Menurut (Lewis , 2018 ) UMUX memiliki skala dari 1 ( sangat tidak setuju ) hingga 7 ( sangat setuju) dengan skor item dimanipulasi untuk mendapatkan skor keseluruhan berkisar dari 0 hingga 100. Berikut tingkat yang dapat diterima sebagai kelayakan skor UMUX:

\begin{itemize}
\item Reliability (Koefisien alfa lebih besar dari 0.80).

\item Concurrent validity (korelasi dengan SUS lebih besar dari 0.55, korelasi CSUQ sama dengan 0.65).

\item Sensitivitas terhadap tingkat yang berbeda dari berbagai variabel independen (misalnya, membedakan antara sistem yang dinilai secara independen dari tingkat kegunaan yang relatif baik dan buruk, mendeteksi perbedaan dalam kegunaan yang dirasakan sebagai fungsi dari pengalaman).

\end{itemize}

\par Menurut (Finstad, 2010) berikut cara menghitung skor UMUX :

\begin{enumerate}
\item Item ganjil diberi skor [ skor pengguna - 1]. Item genap diberi skor [7 - skor pengguna].

\item Jumlahkan perbedaan ini dan bagi jumlahnya dengan 24 (skor tertinggi).

\item Kalikan hasil dengan 100.

\item Cari nilai rata-rata dari seluruh pengguna.
\end{enumerate}

\section{Penelitian Terkait}



%-----------------------------------------------------------------------------%

% Baris ini digunakan untuk membantu dalam melakukan sitasi
% Karena diapit dengan comment, maka baris ini akan diabaikan
% oleh compiler LaTeX.
\begin{comment}
\bibliography{daftar-pustaka}
\end{comment}
